import { Component, OnInit, ViewChild } from '@angular/core';
import { QuestionService } from 'src/app/shared/service/question.service';
import { Exam } from 'src/app/shared/module/exam';
import { MatTableDataSource, MatPaginator, MatDialogConfig, MatDialog } from '@angular/material';
import { trigger, state, transition, animate, style } from '@angular/animations';
import { NotificationService } from 'src/app/shared/service/notification.service';
import { QuestionFormComponent } from '../question-form/question-form.component';
import { Question } from 'src/app/shared/module/question';

@Component({
  selector: 'app-question-list',
  templateUrl: './question-list.component.html',
  styleUrls: ['./question-list.component.css'],
  animations: [
    trigger('detailExpand', [
      state('collapsed', style({ height: '0px', minHeight: '0', visibility: 'hidden' })),
      state('expanded', style({ height: '*', visibility: 'visible' })),
      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
    ]),
  ]
})
export class QuestionListComponent implements OnInit {

  exams: Exam[] = [];

  position = 0;
  questions = [];
  questionData: MatTableDataSource<any>;
  displayedColumns: string[] = ['srNo', 'question'];
  searchKey: string = "";
  currentElement: Element;
  @ViewChild(MatPaginator) paginator: MatPaginator;

  isExpansionDetailRow = (i: number, row: Object) => {
    console.log(row);
    return row.hasOwnProperty('detailRow');
  }
  expandedElement: any;

  constructor(
    private questionService: QuestionService,
    private dailog: MatDialog,
    private notificationService: NotificationService
  ) {
    dailog.afterAllClosed.subscribe(
      () => {
        this.getEnabledExam();
        this.fetchQuestionList();
      }
    )
  }

  ngOnInit() {
    this.getEnabledExam();
    this.fetchQuestionList();
  }

  getRows() {
    const rows = [];
    this.questions.forEach((element: Question) => rows.push(element, { detailRow: true, element }));
    console.log(rows);
    return rows;
  }

  toggleRow(value: Element | null) {
    const foundElement = this.questionData.data.find(elem => elem.element !== undefined && elem.element.id == value.id)
    console.log("The found element is " + JSON.stringify(foundElement.element));
    const index = this.questionData.data.indexOf(foundElement);
    this.questionData.data[index].element.show = !this.questionData.data[index].element.show;
  }

  // toggleRow(element) {
  //   this.questionData.data.find()
  //   // this.fetchQuestionList();
  // }

  // get enabled exam
  getEnabledExam() {
    this.questionService.getExams().subscribe(
      res => {
        this.exams = res.filter(exam => exam.examStatus == true);
        console.log(this.exams);
      }
    )
  }

  // get exam code
  changeExam(code: number) {
    this.questionService.selected = code;
    // this.fetchQuestionsById();
    this.fetchQuestionList();
    console.log(this.questionService.selected);
  }

  // get all question
  fetchQuestionList() {
    this.questionService.getQuestions().subscribe(
      res => {
        const rows = [];
        this.questions = res.filter(x => x.examCode == this.questionService.selected).map((obj, index) => ({ ...obj, show: false, position: index + 1 }));
        console.log(this.questions);
        this.questions.forEach((element: Question) => rows.push(element, { detailRow: true, element }));
        this.questionData = new MatTableDataSource(rows);
        // this.toggleRow();
        this.toggleRow(null);
        this.questionData.paginator = this.paginator;
      }
    )
  }

  // clear searchbox
  onSearchClear() {
    this.searchKey = "";
    this.applyFilter();
  }

  // filter input
  applyFilter() {
    this.questionData.filter = this.searchKey.trim().toLowerCase();
  }

  // popup for insert user
  onCreate() {
    this.questionService.initializeFormGroup(this.questionService.selected);
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    dialogConfig.width = "30%";
    this.dailog.open(QuestionFormComponent, dialogConfig);
  }

}
